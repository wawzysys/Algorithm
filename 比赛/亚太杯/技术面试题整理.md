# 技术面试题整理

## C/C++ 问题

### const 的作用与使用
const 的主要作用包括：
- 修饰变量，说明该变量不可被改变
- 修饰指针，分为指向常量的指针和常量指针
- 修饰引用，指向常量的引用
- 修饰成员函数，说明该成员函数内不能修改成员变量

使用示例：
```cpp
class A {
private:
    const int a;                // 常对象成员

public:
    A() : a(0) { };
    A(int x) : a(x) { };       // 初始化列表

    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数
};

void function() {
    // 对象
    A b;                        // 普通对象
    const A a;                  // 常对象
    const A *p = &a;           // 指向常对象的指针
    const A &q = a;            // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指向变量的指针
    const char* p2 = greeting;          // 指向常量的指针
    char* const p3 = greeting;          // 常量指针
    const char* const p4 = greeting;    // 指向常量的常量指针
}
```

### 面向对象三大特征

1. **封装**
- 把客观事物封装成抽象的类
- 类可以把自己的数据和方法只让可信的类或对象操作
- 关键字：public, protected, private
- 不写默认为 private

2. **继承**
- 基类（父类）——> 派生类（子类）

3. **多态**
C++ 多态分类：
- 重载多态（编译期）：函数重载、运算符重载
- 子类型多态（运行期）：虚函数
- 参数多态性（编译期）：类模板、函数模板
- 强制多态（编译期/运行期）：基本类型转换、自定义类型转换

### 虚函数
- 作用：实现动态多态
- 实现机制：通过虚函数表（vtable）
- 特点：
  - 每个有虚函数的类都有虚函数表
  - 类对象存储空间的最前端存放虚函数表指针
  - 虚函数表在编译时生成

### 多重继承

C++支持多重继承，但可能带来以下问题：

1. **菱形继承问题**
- 当两个基类继承自同一个基类时可能导致资源冗余
- 解决方案：使用虚继承

2. **虚继承的使用**
- 使用 virtual 关键字
- 共享基类的单一实例
- 最派生类负责初始化虚基类

3. **虚继承的影响**
- 可能增加额外的内存开销
- 需要更细致地管理构造函数和初始化顺序

### 智能指针

1. **std::shared_ptr 特性**：
- 通过引用计数管理对象生命周期
- 当引用计数为零时自动释放内存
- 需要注意避免循环引用问题
- 可以使用 std::weak_ptr 解决循环引用

2. **引用计数工作原理**：
- 创建时计数为1
- 拷贝时计数增加
- 析构时计数减少
- 计数为0时释放资源

### 什么是共享指针（std::shared_ptr），它的主要用途是什么？ 

- 定义：std::shared_ptr是C++标准库中的智能指针类型，用于管理动态分配的对象的生命周期。它通过引用计数来跟踪有多少共享指针指向同一个对象，当最后一个共享指针被销毁时，对象的内存会被自动释放。 

- 主要用途：共享指针主要用于避免手动内存管理带来的内存泄漏和悬空指针问题，特别适用于需要在多个地方共享同一个对象的场景。  

### 共享指针的引用计数是如何工作的？ 

- 引用计数：每个std::shared_ptr对象内部维护一个引用计数器，记录有多少个共享指针指向同一个对象。 
- 增加计数：当一个新的std::shared_ptr对象被创建并指向一个已经存在的对象时，引用计数器会增加。 
- 减少计数：当一个std::shared_ptr对象被销毁或重置时，引用计数器会减少。 
- 释放内存：当引用计数器减少到零时，表示没有共享指针指向该对象，对象的内存会被自动释放。 

### 共享指针如何避免循环引用（Circular Reference）问题？ 

- 循环引用问题：当两个或多个对象互相持有std::shared_ptr指向对方时，会导致引用计数永远不为零，造成内存泄漏。 
- 解决方法：使用std::weak_ptr来打破循环引用。std::weak_ptr是一个弱引用，不会增加引用计数，可以安全地检查对象是否仍然存在。

## Python 问题

### 负索引与切片
```python
# 列表反转
my_list[::-1]
```

优势：
- 减少代码行数
- 使复杂操作更简单
- 提高操作效率
- 反转列表操作： my_list[::-1]

### 装饰器
- 用于在不改动函数的前提下扩展功能
- 基于闭包(closure)实现
- 可以通过闭包捕获参数实现定制化

`详细`

- > 用来装饰某个已经存在的函数，在不改动这个函数的前提下，扩展这个函数的功能。 

  > 装饰器的实现基础就是闭包(closure)，可以将被修饰的函数对象嵌入到另外一个函数对象中

- > 并且通过闭包的概念，将扩展功能需要的参数，捕获到闭包内，从而实现装饰器属性的定制化设置。

## Java 问题

### ArrayList vs LinkedList

**ArrayList**:
- 基于数组实现
- 随机访问快 O(1)
- 中间插入删除慢 O(n)
- 内存占用相对较小

**LinkedList**:
- 基于双向链表实现
- 随机访问慢 O(n)
- 插入删除快 O(1)
- 内存占用较大

使用场景：
- ArrayList：适合随机访问和遍历
- LinkedList：适合频繁的插入和删除操作

- 内部实现： 
  - ArrayList是基于数组实现的动态数组，它可以根据需要自动扩容和缩容。 
  - LinkedList是基于双向链表实现的，每个节点都包含了前一个节点和后一个节点的引用。 
- 插入和删除操作： 
  - ArrayList在
    - 末尾，O(1)。
    - 中间\开头，O(n)。 
  - LinkedList
    - 在任意位置进行插入和删除操作的效率较高，时间复杂度为O(1)。因为只需要修改节点的引用，不需要移动元素。 
- 随机访问： 
  - ArrayList，O(1)。 
  - LinkedList需要从头或尾开始遍历链表，直到找到目标位置，时间复杂度为O(n)。 
- 内存占用：
  -  ArrayList在内存中连续存储元素，因此占用的内存空间相对较小。 
  - LinkedList需要额外的空间存储节点的引用，因此占用的内存空间相对较大。 
- 适用场景：
  -  ArrayList适用于需要频繁随机访问元素的场景，例如根据索引快速获取元素、遍历元素等。
  -  LinkedList适用于需要频繁插入和删除元素的场景，例如在链表的头部或尾部进行插入和删除操作、实现队列或栈等数据结构。 
  - 需要根据具体的使用场景和需求来选择合适的集合实现。如果需要频繁随机访问元素，且对内存占用有要求，可以选择ArrayList。如果需要频繁插入和删除元素，或者对随机访问的性能要求不高，可以选择LinkedList。

### JDK1.8线程池创建方式
1. Executors工厂方法：
```java
ExecutorService executorService = Executors.newFixedThreadPool(nThreads);
ExecutorService executorService = Executors.newCachedThreadPool();
ExecutorService executorService = Executors.newSingleThreadExecutor();
ExecutorService executorService = Executors.newScheduledThreadPool(corePoolSize);
```

这些方法都返回一个ExecutorService对象，可以用于执行任务。

2. ThreadPoolExecutor构造方法：

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize, 
    maximumPoolSize, 
    keepAliveTime, 
    TimeUnit unit, 
    workQueue
);
```

通过指定核心线程数、最大线程数、线程空闲时间、任务队列等参数来创建线程池。

3. ForkJoinPool：

```java
ForkJoinPool forkJoinPool = new ForkJoinPool(parallelism);
```

>ForkJoinPool是Java 7引入的用于支持分治任务的线程池，可以用于执行ForkJoinTask任务。 

> 需要注意的是，以上方式创建的线程池都实现了ExecutorService接口，可以使用execute()方法提交任务，也可以使用shutdown()方法关闭线程池。 

> 在选择创建线程池的方式时，需要根据具体的需求和场景来选择合适的线程池类型和参数配置。例如，newFixedThreadPool()适用于固定线程数的场景，newCachedThreadPool()适用于任务数量不确定的场景，newScheduledThreadPool()适用于需要定时执行任务的场景等。

### Spring Boot自动配置原理

> Spring Boot的自动配置原理是基于条件注解和Spring的条件化配置机制实现的。它通过扫描classpath下的特定条件注解，根据条件判断是否需要自动配置相关的组件和功能。

1. 扫描过程：
- 启动时扫描 classpath 下的 META-INF/spring.factories
- 加载自动配置类 - Spring Boot根据自动配置类的全限定名，通过**反射机制实例化**这些自动配置类。

2. 条件注解：
- @ConditionalOnClass
- @ConditionalOnProperty
- 根据条件决定是否启用配置

3. 实现机制：
- 反射机制实例化配置类
- 注册Bean到Spring容器
- 可通过配置属性调整行为

## 数据结构

### 哈希表

1. 构造方法：
- 直接定址法
- 除留余数法
- 数字分析法
- 折叠法
- 平方取中法

2. 冲突处理：
- 链地址法
- 开放定址法：
  - 线性探测法
  - 二次探测法
  - 随机探测法

### 平衡二叉树（AVL树）

1. 特性：
- 左右子树高度差不超过1
- 是二叉搜索树
- 最小平衡树节点公式：F(n)=F(n-1)+F(n-2)+1

2. 调整方式：
- LL型：右旋
- RR型：左旋
- LR型：先左旋后右旋
- RL型：先右旋后左旋

### 红黑树

特征：
1. 节点是红色或黑色
2. 根节点是黑色
3. 所有叶子都是黑色
4. 红色节点的子节点必须为黑色
5. 从任一节点到其每个叶子的所有路径包含相同数目的黑色节点

调整操作：
- 变色
- 左旋
- 右旋

### B树与B+树

区别：
1. B+树只有叶子节点存储数据
2. B+树所有叶子节点通过指针连接
3. B+树内部节点可以存储更多索引项

B树优点：
- 内部节点可以直接获取数据

B+树优点：
- 叶子节点链表便于范围查询
- 内部节点可存储更多索引项
- 查询性能更稳定

数据库选择B+树原因：
1. 减少磁盘IO操作
2. 叶子节点链表结构方便范围查询
3. 内部节点可以存储更多索引

### 线段树

特性：
1. 完全二叉树结构
2. 叶子节点长度为1
3. 非叶子节点区间是左右子节点区间的合并
4. 时间复杂度：
   - 更新：O(logn)
   - 查询：O(logn)

## 网络

### TCP拥塞控制

1. 方法：
- 慢开始
- 拥塞避免
- 快重传
- 快恢复

2. 算法：
- TCP Tahoe
- TCP Reno
- TCP NewReno
- TCP CUBIC
- BBR

3. 选择考虑：
- 网络环境特征
- 延迟要求
- 带宽利用率

### TCP 可靠传输保证
1. 确认和超时重传
2. 数据分片和排序
3. 流量控制
4. 拥塞控制
5. 数据校验

### TCP 连接管理
- 三次握手建立连接
- 四次挥手释放连接

## 消息中间件

### Kafka vs RocketMQ

消费模型区别：
1. **Kafka (Push模型)**：
- 主动推送消息给消费者
- 适合实时性要求高的场景
- 需要维护长连接

2. **RocketMQ (Pull模型)**：
- 消费者主动拉取消息
- 适合控制消费速率场景
- 可根据处理能力调整拉取频率

选择考虑因素：
- 实时性要求
- 消费者处理能力
- 消息顺序性要求
- 吞吐量需求
- 运维复杂度

## 智力题目

### 5L和6L容器得到3L水

解决步骤：
1. 倒满6L容器，倒入5L容器，剩1L
2. 5L容器倒空，将1L倒入5L容器
3. 重复上述步骤，最终可得到3L水

### 链表反转（left到right位置）

要求：
- 1 <= n <= 500
- -500 <= Node.val <= 500
- 1 <= left <= right <= n

进阶要求：
- 一趟扫描完成反转