1、最后愁时的定时任务索引号
有这样一个定时器系统:
(1)该系统精度为1刻度、可容纳n个超时任务(即容量为n);
(2)每个任务里包含该任务超时时刻t(当系统时钟到达t时，该任务开始执行)，t为正整数:
(3)同一时刻超时的任务按照加入系统的先后顺序依次执行超时任务;(4)当定时器系统中任务数不足n个时，可直接添加定时任务:
(5)当定时器系统中任务数达到n个时，假定待添加任务的超时时刻为ti，系统中最后执行的任务的超时时刻为t;
如果 ti>tj,丢弃待添加的任务;否则丢弃系统中最晚执行的超时任务，并将待添加任务加入系统中。
现给定该定时器系统容量n，短时内(不到1刻度)依次向该定时器系统添加m个定时任务tasks，假定当前时钟为0时刻，即向该定时器系统添加的任务都是尚未超时的任务。请输出该定时器系统中最后超时的任务索引号，其中索引号是指:当前task在tasks中的下标(下标从0开始计数);如果多个任务同时超时，请输出最大的索引号。
解答要求
时间限制: C/C++1500ms,其他语言:3000ms内存限制: C/C++64MB,其他语言:128MB
输入
第一行:定时器系统容量n;1<=n<=10^3
第二行:定时任务数m;1<=m<=10^6
第三行:定时任务列表内容tasks，每个数据通过空格隔开:1<=tasks(i
<= 10^5

输出
输出最后超时的任务索引号
样例1
输入:
2
12
1 2 3 4 6 19 20 21 22 23 25 1
 输出:11
解释:定时器系统容量为2，最多容纳2个定时任务，因此最终定时器里只会存在两个任务:分别是1(索引号0)、1(素引号11)，这两个任务同时超时，题目要求返回更大的索引，因此返回11
样例2
 输入:
1
2
10 2
输出:1
解释:定时器系统容量为1，最多容纳1个定时任务，因此最终定时器里只会存在1个任务:2;2对应索引号为1，因此返回1
样例3
输入:
20
5
1 2 3 4 5
输出:
4
解释:定时器系统容量为20，最多容纳20个定时任务，而添加的任务数为5没有超过定时器系统规格，因此最终定时器里会存在以下任务:1 2 3 4 5;
5最晚超时，因此返回5对应的下标4

# 2
2、求一组算子的最短执行时间
深度学习算法由一个个计算单元组成，我们称这些计算单元为算子。对于完成矢量运算的算子我们称为矢量算子，在NPU中矩阵计算单元和向量计算单元都可以执行矢量算子，他们是独立可并行执行的，但他们的计算效率是6:1，即假设某个矢量算子在矩阵计算单元上执行的时间为N，则在向量计算单元上执行的时间为6N。给定一组矢量算子，假设他们都可以部署在矩阵计算单元和向量计算单元。为了充分利用计算资源，我们可以合理部署算子的执行单元，让总体的执行时间最短，总的执行时间为MAX(矩阵计算单元总的执行时间，向量计算单元总的执行时间)。为了简化计算模型，我们约定:
1.单个算子只能部署在矩阵计算单元或向量计算单元。
2.部要在向量计算单元的算子必须是按照给定顺序连续的。
解答要求
时间限制: C/C++800ms,其他语言:1600ms
内存限制: C/C++32MB,其他语言:64MB
输)
输入格式:
第一行输入算子数n
第二行输入该组算子在矩阵计算单元的执行时间nums
1 <=n<= 10^4
1 <= nums[i]<= 10^4
输出
该组算子整体的最短执行时间

样例1
复制 输入:
9
1 2 3 4 5 6 7 8 9
复制 
输出:39
解释:下标5的算子在矩阵计算单元的执行时间为6，将它部要在向量计算单元，执行时间变为6*6=36，剩下的算子部要在矩阵计算单元，执行时间为1+2+3+4+5+7+8+9=39,总的执行时间为39，没有比这执行时间更短的方案了。
样例2
复制 输入:
9
3 2 17 8 3 5 4 18 15
复制 输出:66
解释:下标3,4的算子在矩阵计算单元的执行时间为8,3，将它部要在向量计算单元，执行时间变为8*6+3~6=66，剩下的算子部要在矩阵计算单元，执行时间为3+2+17+5+4+18+15=64，总的执行时间为66，没有比这执行时间更短的方案了。

# 3
3、最小换序代价
给定2个长度为均为n的整数数组nums1和nums2，每次操作可以交换数组nums2中任意2个元素，其代价为两个下标的和。目标是对于所有的下标i，0<=i<n，n为数组的长度，都满足nums1[i]!=nums2[i]。
返回满足目标的最小代价和，如果达不成目标，返回-1.
解答要求
时间限制: C/C++300ms,其他语言:600ms
内存限制: C/C++32MB,其他语言:64MB
输入
输入格式:
第一行输入整数数组的长度n
第二行输入长度为n的整数数组nums1第三行输入长度为n的整数数组nums2
1 <= n <= 10^5
1 <=nums1[i],nums2[i]<=10^5
输出
最小代价和


样例1
输入:
4
1 2 3 4
1 2 3 4
输出:6
解释:其中代价和最小的一种方法为:
交换下标为0和1的两个值，代价为0+1=1。现在nums1=[2,1,3,4]。
交换下标为2和3的两个值，代价为2+3=5。现在nums1=[2,1,4,3]。
总代价为6。
样例2
复制 输入:
3
2 1 1
1 1 2
复制 输出:-1
解释:无论怎么操作，都无法要求。所以返回-1。