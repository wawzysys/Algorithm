## 1简单双边滤波
双边滤波(Bilateral riter)是一种在图像处理中常用的非线性滤波器，它能够同时考虑图像的空间接近度和像素相似度。定义3x3简化双边滤波
$$
p(x, y) = \sum_{i, j} w(i, j) \cdot p(x + i, y + j)
$$

其中 \( i, j = -1, 0, 1 \)：

$$
w(i, j) = 512 - (128 \cdot i^2 + 128 \cdot j^2 + | p(x + i, y + j) - p(x, y) |)
$$

且滤波系数要归一化，使得滤波系数之和为1。注意：

1. 超出边缘的像素不参与滤波；
2. 输出像素值 round 取整后上下限幅至 [0, 255]；
3. round 定义为：floor(x + 0.5)

解答要求
输入
-张n行n列的单通道图像,像素取值[0,255],第一行输入n后面输入h*n矩阵
输出
滤波后的n"n矩阵,每个元素一行
输入:2
136 250
96 128
输出：
147
182
127
145

## 2
实现一个简单的单隐层神经网络并完成推理，输出推理结果。输入为长度为 \( M \) 的整数向量 \( x \)，输出为整数标量 \( y \)，计算公式为：

$$
y = W2 * f(W1 * x + b1)
$$

其中 \( W1 \) 为 \( N \) 行 \( M \) 列整数矩阵， \( b1 \) 为 \( N \) 行整数向量，\( W2 \) 为长度 \( N \) 的整数向量。

\( f(z) \) 为激活函数，定义为首先计算 abs(z) 比特1的个数，如果为奇数则输出1，否则输出0。
输入：

首先输入 \( M \) 和 \( N \)，然后依次是 \( x, W1, b1, W2 \)

输出：

\( y \)

样例
输入
1 1
1
0
1
-1
输出:
-1



## 4. Hamming译码

汉明码符号表：
```
(7,4) 汉明码符号生成矩阵 G：
[1, 0, 0, 0, 1, 0, 1]
[0, 1, 0, 0, 1, 1, 1]
[0, 0, 1, 0, 1, 1, 0]
[0, 0, 0, 1, 0, 1, 1]
```
输入为长度为4的信道比特序列b。可生成的有效码字集合为：
```
[0, 0, 0, 0, 0, 0, 0]
[1, 0, 0, 0, 1, 0, 1]
[0, 1, 0, 0, 1, 1, 1]
[1, 1, 0, 0, 0, 1, 0]
[0, 0, 1, 0, 1, 1, 0]
...
```
比特为 max-log-map译码器译码定义。给定7个输入 LLR 软值，输出前4个信息比特的译码软值，其中第i比特的软值：
$$
llr[i] = \sum_{j, j \neq i} (s1[j] \cdot LLR[j]) - \sum_{j, j \neq i} (s0[j] \cdot LLR[j])
$$


其中序列s1表示比特位置i取值为1的码字子集，最优的码字，s0表示比特位置i取值位0的的码字子集中，最优的码子。
最优的码子定义为集合中码子s与LLR点积
$$
\sum_{j} (s[j] \cdot LLR[j])
$$
后值最大的那个码字。


### 输入

输入 7 个 LLR 软值

### 输出

4 个信息比特的译码软值

### 样例 1：

**输入**：
```
-13
24
-17
27
12
31
14
```

**输出**：
```
10  
-15 
14  
-30
```

## 5. 寻找元素和最小的子矩阵

给定一个 \( N \) 行 \( N \) 列的矩阵，寻找一个行、列连续的 \( K \times K \) 子矩阵（\( 1 \leq K \leq N \)），使得子矩阵的元素和最小，输出该最小值。

### 解答要求

- 时间限制：C/C++ 200ms，其他语言：400ms
- 内存限制：C/C++ 256MB，其他语言：512MB

### 输入

首先输入 \( N \)，然后输入 \( N \) 行 \( N \) 列的矩阵

### 输出

最小值

### 样例 1：

**输入**：
```
2
38 40
-64 -63
```

**输出**：
```
-64
```