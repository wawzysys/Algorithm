
# 1
一个正整数数组，数组的长度区间为[2,100]，数组中每个数字的大小范围为[1,10^4]
找出该数组中，相加后结果最大的一对等高数，输出它们的和，如果数组中没有等高数则输出-1。
输入
[196,161,23,81,38,92]
输出:
288
说明:
存在196与92、81与38两组等高数，由于196+92>81+38，所以结果为288
输入:
[1,2.3,4]
输出:
-1
思路写在注释中了
```python
nums = [int(x) for x in input()[1:-1].split(',')]
d = {}
for n in nums:
    m = max(map(int, str(n)))  # 找到每个数的最大位
    d.setdefault(m, []).append(n)  # 按最大位存储等高数

res = -1
for v in d.values():
    if len(v) > 1:  # 如果有至少两数等高
        v.sort(reverse=True)  # 按降序排序
        res = max(res, v[0] + v[1], res)  # 取当前最大的和

print(res)

```
# 2
游戏中有一排怪物，每个怪物会以相同的速度向左或者向右移动，然后每个怪物有能力值，当两个怪物碰到后，能力值较大的怪物会消灭能值较小的怪物，如果两个怪物能力值相同，那两个怪物会被同时消灭，两个移动方向相同的怪物永远不会碰面，我们需要计算最后剩余哪些怪物。我们使用一个数组monsters，表示这一排怪物，对于数组中的每一个元素，他的绝对值表示这个怪物的能力值，正数代表怪物向右移动，负数代表怪物向左移动。
输入描述
使用一个数组monsters，表示这一排怪物，对于数组中的每一个元素，他的绝对值表示这个怪物的能力值，正数代表怪物向右移动，负数
代表怪物向左移动
输出描述
输出最后剩下的怪物有哪些，请严格按照示例的格式输出，元素之间用“，隔开，并存在一个空格，比如[5，10]
输入
[5, 10,-5]
输出:
[5, 10]
输入
[10, 10]
输出:
[]

思路写在注释中了
```python
monsters = eval(input())  # 输入怪物列表
s = []  # 用栈来模拟怪物碰撞的过程

for x in monsters:
    while s and s[-1] > 0 and x < 0:  # 栈顶怪物向右，当前怪物向左，可能发生碰撞
        if abs(s[-1]) == abs(x):  # 能力值相同，两者都消灭
            s.pop()  # 栈顶怪物消失
            break  # 当前怪物也消失
        elif abs(s[-1]) > abs(x):  # 栈顶怪物能力值大，当前怪物消失
            break
        else:  # 当前怪物能力值大，栈顶怪物消失
            s.pop()
    else:
        s.append(x)  # 当前怪物未被消灭，入栈

print(f"[{', '.join(map(str, s))}]")

```
